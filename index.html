<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .answer {
            background: rgb(118, 223, 74); display: inline-block;
        }
        .answer-pre {
            background: rgb(118, 223, 74); padding: 10px;
        }
    </style>
</head>
<body>
    <h1>Верстка та Загальне</h1>
    <ol>
        <li>Чи можна з js змінювати значення before, after?</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            Так, за допомогою JavaScript можна змінити значення цих псевдоелементів.
            Щоб отримати доступ і змінити стилі псевдоелементів before і after за допомогою JavaScript,
            ви можете використовувати метод window.getComputedStyle(), щоб отримати обчислені стилі елемента,
            а потім за потреби змінити властивість вмісту псевдоелемента до або після .
        </pre>
        </br>
        <hr>
        </br>
        <li>Що вказує значення "1em" і якого параметра він прив'язаний</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            1em вказує розмір відносно розміру шрифту елемента (2em означає 2-кратний розмір поточного шрифту).
            Таким чином, значення "1em" пов'язане з властивістю font-size елемента,
            воно часто використовується для створення масштабованих макетів і тексту,
            який регулює свій розмір відповідно до розміру шрифту його батьківського елемента.
        </pre>
        </br>
        <hr>
        </br>
        <li>Вмістити три блоки 20X20px в ряд, блок шириною 60px, при цьому у блоків повинні бути межі. Реалізуйте всі варіанти, які знаєте.</li>
        <img height="300" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8wAAAKHCAMAAABjHjFHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJnUExURf////7+/v7//ujz6avTrqTTqKnYranZraXUqZ3MoZ3NoZ3MoJ7NoaLPpdDn0r/ewg+DGQB3BAd9EQd9EAZ9EAh+EgqAFAZ/EAB3Ane5fL3gwAmCEwBAAAAZAAAQAAAOAAAPAAAjAAAkAAAaAAARADZfOqvUr7LbtbbZuZDGlQd/EWixbsDjwxKIHAAiAAoACTowOUU8REE4QEI6QkQ7Qx8WHgAAABsSGkM6QjwzO1dOVuv06xyKJmewbcDiwwAbACkhKd7d3vb29vv7+3h3eGZmZv39/ejn6CUlJURERNvt3RqJIy4mLfHw8YKCgnBwcCoqKkJCQtvs3CsjK+bl5nt7e2pqavDw8CcnJ0NDQy4lLvbt9YSAhHJucf/5/yopKkhGSGawbb7hwQqEFCEfIK3LsMzwz8Tnx8ntzF1uX1BeUcbpycbpyMvvzrXWuB8kHzA5MLjbu7/jwrjau8ThxpzMoAmAEwuEFQMPBBB5GROQHRKLHBOOHQhBDQg5DBKMHBOPHRGAGwMVBQIhBQuBFQuGFgyBFQB1AHS3eur47KXUqDtMPAAnAAAwAAAtAAAuAAAvAAAXAAAcAAAdACUzJpbOm5DGlI/FlJXImcrkzG5rbgUGBSUmJS8rLisjKiojKhsaG3l3eWhnaBkZGcLCwvf29+fm5+fm5uXl5e/v711dXQUFBXFxcYeHh39/f4aGhiwsLBYWFuHh4VNTUx0dHQwMDNHR0VRUVBwcHOjo6G1tbQ0NDdLS0hsbG+Pj42trax4eHvLy8nNzcxQUFMvLy1xcXFlZWQoKCtPT06WlpXh4eOfn5wAAAGFSrFwAAADNdFJOU///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////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"
        /></br>


        <h2 class="answer">Answer:</h2>
        <br>
        <h3 class="answer">Approach 1</h3>
        <br>
        <h5 class="answer">HTML:</h5>
        <pre class="answer-pre">
            &lt;div class="container"&gt;
                &lt;div class="float-left"&gt;1&lt;/div&gt;
                &lt;div class="float-left"&gt;2&lt;/div&gt;
                &lt;div class="float-left"&gt;3&lt;/div&gt;
            &lt;/div&gt;
        </pre>
        <h5 class="answer">CSS:</h5>
        <pre class="answer-pre">
            <code>
                .float-left {
                    float:left;
                    width: 33.333%;
                    background-color: crimson;
                    border: 1px solid black;
                    text-align: center;
                    height: 20px;
                    box-sizing: border-box;
                }
                .container {
                    width: 60px;
                }
            </code>
        </pre>
        <br>
        <h3 class="answer">Approach 2</h3>
        <br>
        <h5 class="answer">HTML:</h5>
        <pre class="answer-pre">
            &lt;div class="container"&gt;
                &lt;div class="column"&gt;1&lt;/div&gt;
                &lt;div class="column"&gt;2&lt;/div&gt;
                &lt;div class="column"&gt;3&lt;/div&gt;
            &lt;/div&gt;
        </pre>
        <h5 class="answer">CSS:</h5>
        <pre class="answer-pre">
            <code>
                .container {
                    display: table;
                    width: 600px;
                    table-layout: fixed;
                  }
                .column {
                    display: table-cell;
                    background-color: crimson;
                    height: 200px;
                    width: 33.333%;
                    border: 1px solid black;
                    text-align: center;
                    box-sizing: border-box;
                }
            </code>
        </pre>
        <br>
        <h3 class="answer">Approach 3</h3>
        <br>
        <h5 class="answer">HTML:</h5>
        <pre class="answer-pre">
            &lt;div class="flex-container"&gt;
                &lt;div class="flex-child"&gt;
                    1
                &lt;/div&gt;
                &lt;div class="flex-child"&gt;
                    2
                &lt;/div&gt;
                &lt;div class="flex-child"&gt;
                    3
                &lt;/div&gt;
            &lt;/div&gt;
        </pre>
        <h5 class="answer">CSS:</h5>
        <pre class="answer-pre">
            <code>
                .flex-container {
                    display: flex;
                    width: 600px;
                }
                .flex-child {
                    flex: 1;
                    border: 1px solid black;
                    background-color: crimson;
                    text-align: center;
                    height: 200px;
                    box-sizing: border-box;
                }
            </code>
        </pre>
        <br>
        <h3 class="answer">Approach 4</h3>
        <br>
        <h5 class="answer">HTML:</h5>
        <pre class="answer-pre">
            &lt;div class="grid-container"&gt;
                &lt;div class="grid-child"&gt;
                    1
                &lt;/div&gt;
                &lt;div class="grid-child"&gt;
                    2
                &lt;/div&gt;
                &lt;div class="grid-child"&gt;
                    3
                &lt;/div&gt;
            &lt;/div&gt;
        </pre>
        <h5 class="answer">CSS:</h5>
        <pre class="answer-pre">
            <code>
                .grid-container {
                    display: grid;
                    grid-template-columns: 1fr 1fr 1fr;
                    width: 600px;
                }
                .grid-child {
                    border: 1px solid black;
                    box-sizing: border-box;
                    height: 200px;
                    background-color: crimson;
                    text-align: center;
                }
            </code>
        </pre>
        <br>
        <hr>
        <br>
        <li>Є масив, де лежать об'єкти з датами, відсортуйте його за датами.
            </br>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        let array = [
            {date: '2017-01-10'},
            {date: '2016-05-18'},
            {date: '2002-12-20'},
            {date: '2020-06-30'}
        ];
            </code></pre>
        </li>

        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            <code>
                let array = [
                    {date: '2017-01-10'},
                    {date: '2016-05-18'},
                    {date: '2002-12-20'},
                    {date: '2020-06-30'}
                ];

                let rightFormatDateArr = array.map( el => {
                    return {...el, date: new Date(el.date)};
                });

                const arrAsc = [...rightFormatDateArr].sort(
                    (elA, elB) => Number(elA.date) - Number(elB.date),
                );

                const arrDesc = [...rightFormatDateArr].sort(
                    (elA, elB) => Number(elB.date) - Number(elA.date),
                );

                const resAsc = arrAsc.map( el => {
                    return {...el, date: el.date.toLocaleDateString("en-ca")};
                })

                const resDesc = arrDesc.map( el => {
                    return {...el, date: el.date.toLocaleDateString("en-ca")};
                })

                console.log(resAsc);
                console.log(resDesc);
            </code>
        </pre>
        </br>
        <li>Напишіть код, який при натисканні на будь-який div всередині root буде виводити в консоль його id.</li>
        </br>
        <pre style="border: 1px solid grey; padding: 10px"><code>
        &lt;div id="root" style="background: red;">
            root
            &lt;span id="id1" style="background: lightblue;">id1&lt;/span>
            &lt;div id="id2" style="background: green;">
                id2
                &lt;div id="id3" style="background: yellow;">id3&lt;/div>
                &lt;/div>
        &lt;/div>
        </code></pre>
    </ol>

    <h2 class="answer">Answer:</h2>
    <pre class="answer-pre">
        <code>
            const root = document.querySelector('#root');
            root.addEventListener('click', e => {
                if(e.target.tagName === 'DIV') {
                    console.log(e.target.id);
                }
            });
        </code>
    </pre>
    </br>
    <hr>
    <h1>Angular</h1>
    <ol>
        <li>Яка різниця між *ngIf і [hidden]?</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            *ngIf повністю видаляє елемент із DOM, якщо умова хибна. Це означає, що будь-які прив’язки або прослуховувачі подій
            для цього елемента також видаляються. Коли умова знову стане істинною, Angular відтворить елемент
            і повторно застосує будь-які прив’язки та слухачі подій. Це може бути корисно з міркувань продуктивності, оскільки зменшує розмір DOM.

            З іншого боку, [hidden] просто застосовує стиль CSS display: none до елемента, коли умова хибна.
            Це означає, що елемент все ще присутній у DOM, але його не видно. Будь-які прив’язки або прослуховувачі подій для елемента все ще активні. 
            Коли умова знову стає істинною, стиль відображення видаляється, і елемент знову стає видимим.

            *ngIf слід використовувати, коли ви хочете повністю видалити елемент із DOM і його прив’язки та прослуховувачів подій,
            коли він не потрібен, тоді як [hidden] слід використовувати, коли ви хочете приховати елемент,
            зберігаючи його прив’язки та події-слухачі активними.
        </pre>
        </br>
        <hr>
        </br>
        <li>Що таке Observable?</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            Observable — це потік даних, який можна використовувати для обробки асинхронного програмування та програмування на основі подій.
            Це абстрактне представлення будь-якого набору значень, яке можна змінювати з часом і яке сповіщає передплатників щоразу,
            коли з’являється нове значення. Observable можна використовувати для моделювання таких речей, як HTTP-запити,
            введення користувачами та події таймера.

            Observable може видавати одне або кілька значень, а також може видавати помилку або повне сповіщення.
            Це виробник значень, які можуть споживатися одним або декількома передплатниками, і забезпечує спосіб обробки асинхронних операцій
            у більш раціональний та реактивний спосіб. За допомогою Observables розробники можуть писати код, який є більш лаконічним,
            читабельним і придатним для обслуговування, особливо при роботі зі складними асинхронними сценаріями.
        </pre>
        </br>
        <hr>
        </br>
        <li>
            <p>Розглянемо наступний компонент:</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        import { Component, Input } from '@angular/core';

        @Component({
        selector: 'welcome',
        template: `&lt;h1>Welcome to {{name}}!&lt;/h1>`,
        styles: [`h1 { font-family: Lato; }`]
        })
        export class WelcomeComponent  {
        @Input() name: string;
        }
            </code></pre>
            <p>Виберіть правильні твердження про його використання (в іншому шаблоні компонента або модулі).</p>
            <p>(Виберіть усі прийнятні відповіді.)</p>
            <ol>
                <li>&lt;welcome name="TestDome">&lt;/welcome> відображатиме: "Welcome to TestDome!".</li>
                <li>&lt;welcome>&lt;/welcome> нічого не відображатиме.</li>
                <li>@NgModule({ declarations: [ WelcomeComponent ] }) export class WelcomeModule {} повідомляє, що компонент привітання належить модулю привітання.</li>
                <li>&lt;hello name="{{ name }}">&lt;/hello> відображатиме: "Welcome to name!".</li>
            </ol>
        </li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            <code>
                1. &lt;welcome name="TestDome"&lt;&lt;/welcome&lt; відображатиме: "Welcome to TestDome!".

                3. @NgModule({ declarations: [ WelcomeComponent ] }) export class WelcomeModule {} повідомляє, що компонент привітання належить модулю привітання.
            </code>
        </pre>
        </br>
        <hr>
        <li>
            <p>Розглянемо наступний компонент, який можна використовувати для моделювання тварини та її шуму.</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        import {Component, Input, Output} from '@angular/core';

        @Component({
        selector: 'animal-noise',
        template: `
            &lt;span>{{animal}}&lt;/span>
            &lt;button (click)="makeNoise()">Make noise&lt;/button>
        `
        })
        export class AnimalNoise {
            @Input('animal') animal: string;
            @Input('noise') noise: string;

            makeNoise() {
                alert(`${this.noise}`);
            }
        }
            </code></pre>
            <p>Виберіть правильні твердження про компонент AnimalNoise.</p>
            <p>(Виберіть усі прийнятні відповіді.)</p>
            <ol>
                <li>Component, Input і Output всі необхідні імпорти цього компонента.</li>
                <li>При включенні компонента AnimalNoise у шаблон мають бути вказані вхідні дані як тварин, так і шуму.</li>
                <li>Параметр 'animal' у оголошенні @Input ('animal') не змінює інтерфейс компонента.</li>
                <li>При включенні до шаблону компонентів компонент AnimalNoise створює діапазон, що містить інтерполіроване ім'я тварин і кнопку, прив'язану до makeNoise().</li>
                <li>Компонент AnimalNoise може бути включений в інший шаблон за допомогою тега &lt;AnimalNoise>.</li>
            </ol>
        </li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            <code>
                2. При включенні компонента AnimalNoise у шаблон мають бути вказані вхідні дані як тварин, так і шуму.
                3. Параметр 'animal' у оголошенні @Input ('animal') не змінює інтерфейс компонента.
                4. При включенні до шаблону компонентів компонент AnimalNoise створює діапазон, що містить інтерполіроване ім'я тварин і кнопку, прив'язану до makeNoise().
                5. Компонент AnimalNoise може бути включений в інший шаблон за допомогою тега &lt;AnimalNoise>.
            </code>
        </pre>
        </br>
        <hr>
        <li>
            <p>Розглянемо наступний модуль програми:</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        import { NgModule }             from '@angular/core';
        import { RouterModule, Routes } from '@angular/router';
        import { HomeComponent }        from './home.component';
        import { ItemDetailComponent }  from './item-detail.component';
        const routes: Routes = [
            { path: '', redirectTo: '/home', pathMatch: 'full' },
            { path: 'home',  component: HomeComponent },
            { path: 'detail/:id', component: ItemDetailComponent, outlet: 'route1' }
        ];
        @NgModule({
            imports: [ RouterModule.forRoot(routes) ],
            exports: [ RouterModule ]
        })
        export class AppRoutingModule {}
            </code></pre>
            <p>Які з таких тверджень щодо поведінки маршрутизаторів є правильними?</p>
            <p>(Виберіть усі прийнятні відповіді.)</p>
            <ol>
                <li>Доступ до домашнього компонента можливий лише через перенаправлення кореневої URL-адреси.</li>
                <li>Параметр id не є обов'язковим, коли виконується виклик / detail / URL.</li>
                <li>Необов'язкові параметри можуть бути передані до будь-якого компонента через параметри запиту ActivatedRoute.</li>
                <li>/detail/100 використовуватиме &lt;router-outlet name='route1'> для визначення позиції виду.</li>
                <li>Route, який перенаправляє на HomeComponent, активується на тих самих маршрутах, якщо властивість pathMatch: 'full' була видалена.</li>
            </ol>
        </li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            <code>
                1. Доступ до домашнього компонента можливий лише через перенаправлення кореневої URL-адреси.
                3. Необов'язкові параметри можуть бути передані до будь-якого компонента через параметри запиту ActivatedRoute.
                5. Route, який перенаправляє на HomeComponent, активується на тих самих маршрутах, якщо властивість pathMatch: 'full' була видалена.
            </code>
        </pre>
        </br>
        <hr>
        <li>
            <p>Розглянемо наступні два базові класи, Positionable і Rotatable, і похідний клас MovingObject:</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        class Positionable {
            locationX: number;
            locationY: number;
        }

        class Rotatable {
            orientation: number;
            rotate(orientation: number) {
                this.orientation += orientation;
            }
            align(rotatable: Rotatable) {
                this.orientation = rotatable.orientation;
            }
        }

        class MovingObject implements Positionable, Rotatable {
            locationX: number = 0;
            locationY: number = 0;
            orientation: number = 0;
            rotate: (orientation: number) => void;
        }

        applyMixins(MovingObject, [Positionable, Rotatable]);
        function applyMixins(derivedCtor: any, baseCtors: any[]) {
            baseCtors.forEach(baseCtor => {
                Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
                    derivedCtor.prototype[name] = baseCtor.prototype[name];
                });
            });
        }

        let mover = new MovingObject();
        mover.rotate(30);
            </code></pre>
            <p>Виберіть правильні твердження.</p>
            <p>(Виберіть усі прийнятні відповіді.)</p>
            <ol>
                <li>Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject.</li>
                <li>Компілятор TypeScript підкреслить, що властивість "align" відсутня для типу MovingObject.</li>
                <li>Оскільки MovingObject реалізує Rotatable, виклик mover.rotate(30) нічого не зробить.</li>
                <li>Клас Positionable можна змінити на інтерфейс без помилок компілятора.</li>
                <li>Властивості MovingObject необхідні як резервні для задоволення компілятора TypeScript.</li>
            </ol>
        </li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            <code>
                1. Функція applyMixins застосовує реалізації Positionable і Rotatable до MovingObject.
                2. Компілятор TypeScript підкреслить, що властивість "align" відсутня для типу MovingObject.
                4. Клас Positionable можна змінити на інтерфейс без помилок компілятора.
            </code>
        </pre>
        </br>
        <hr>
        <li>
            <p>Розглянемо такі компоненти:</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        export class Address {
            street: String;
            city: String;
            zipCode: String;
        }

        @Component({
            selector: 'app-address',
            templateUrl: './address.component.html',
            styleUrls: ['./address.component.css']
        })
        export class AddressComponent implements OnInit {

            @Input() address: Address;
            constructor() { }

            ngOnInit() {

            }
        }

        @Component({
            selector: 'app-address-list',
            templateUrl: './address-list.component.html',
            styleUrls: ['./address-list.component.css']
        })
        export class AddressListComponent implements OnInit {

            @Input() addresses: Address[];
            constructor() { }

            ngOnInit() {

            }
        }
            </code></pre>
            <p>Нижче наведено файл address-list.component.html. Заповніть пробіли, щоб шаблон відображав один елемент li на адресу, і коректно пов'язував кожну адресу з полем AddressComponent.</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        &lt;ul>
            &lt;li <input type="text"/>="let address of <input type="text"/>">
                &lt;app-address <input type="text"/>="address">&lt;/app-address>
            &lt;/li>
        &lt;/ul>
            </code></pre>
        </li>
    </ol>
    <h2 class="answer">Answer:</h2>
    <pre class="answer-pre">
        <code>
            &lt;ul>
                &lt;li *ngFor="let address of addresses">
                    &lt;app-address [address]="address">&lt;/app-address>
                &lt;/li>
            &lt;/ul>
        </code>
    </pre>
    </br>
    <hr>
    <h1>Node JS</h1>
    <ol>
        <li>Що таке файл package.json?</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            Файл `package.json` — це файл конфігурації, який використовується в проектах Node.js для визначення метаданих проекту,
            його залежностей та іншої пов’язаної інформації. Це файл JSON, який містить різні поля, наприклад:
            name: назва проекту або пакета
            version: номер версії проекту або пакета
            description: короткий опис проекту або пакету
            main: точка входу в проект
            dependencies: список пакетів, від яких залежить проект
            devDependencies: список пакетів, які потрібні проекту лише для розробки
            scripts: список команд, які можна запускати для виконання різних завдань, таких як створення або тестування проекту

            Файл `package.json` автоматично створюється, коли ви створюєте новий проект Node.js за допомогою команди `npm init`,
            і зазвичай він знаходиться в кореневому каталозі проекту. Файл можна редагувати вручну, щоб додати або оновити метадані проекту,
            залежності або сценарії.
        </pre>
        </br>
        <hr>
        </br>
        <li>Які є типи запитів HTTP?</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            Основні такі:
            GET: Запитує представлення ресурсу. Він отримує дані з сервера та відображає їх клієнту.
            POST: надсилає інформацію на сервер. Він використовується для надсилання даних на сервер, часто для створення ресурсу.
            PUT: замінює представлення ресурсу. Він використовується для оновлення наявного ресурсу новими даними.
            DELETE: видалення ресурсу, ідентифікованого за URL-адресою. Використовується для видалення ресурсу з сервера.
            HEAD: Запитує відповідь, ідентичну запиту GET, але без тіла відповіді. Він використовується для отримання метаданих ресурсу.
        </pre>
        </br>
        <hr>
        </br>
        <li>Поясніть різницю між локальним і глобальним встановленням пакетів npm</li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            Локально встановлені пакети встановлюються в каталозі `node_modules` вашого проекту.
            Ці пакети призначені для використання у вихідному коді цього проекту, а їхніми залежностями керує файл package.json цього ж проекту.
            Локально встановлені пакети зазвичай встановлюються як devDependencies у файлі package.json вашого проекту за допомогою команди `npm install`.

            З іншого боку, глобально встановлені пакунки встановлюються в системний каталог поза структурою каталогів вашого проекту.
            Ці пакети призначені для використання як інструменти командного рядка або утиліти, доступ до яких можна отримати з будь-якої точки системи.
            Приклади глобально встановлених пакетів включають `nodemon`, `eslint`, `typescript`, `angular-cli`.
            Щоб установити пакет глобально, ви можете скористатися командою `npm install -g`.

            Одна з головних переваг локального встановлення пакетів полягає в тому, що це забезпечує більшу ізоляцію та відтворюваність проекту.
            Різні проекти можуть мати різні версії одного пакета без будь-яких конфліктів.
            Крім того, коли ви ділитеся своїм проектом з іншими, вони можуть легко встановити всі необхідні залежності,
            виконавши команду `npm install` у каталозі проекту.

            Глобально встановлені пакети, з іншого боку, легше використовувати як інструменти командного рядка, і ви можете використовувати
            їх у різних проектах, не встановлюючи їх знову. Однак важливо мати на увазі, що різні версії одного пакета можуть
            конфліктувати одна з одною, тому зазвичай не рекомендується встановлювати пакети глобально, якщо вони справді не призначені
            для використання як загальносистемні інструменти.
        </pre>
        </br>
        <hr>


        </br>
        <li>Поясніть порядок виконання прослуховувачів подій у Node.js. Що буде результатом цього коду і чому?
            </br>
            Розглянемо цей код:
            <pre style="border: 1px solid grey; padding: 10px"><code>
            import { EventEmitter } from 'events';
            const eventEmitter = new EventEmitter();

            eventEmitter.on('myEvent', (data) => {
                console.log(data, '- FIRST');
            });

            console.log('Statement A');

            eventEmitter.on("myEvent", data => {
                console.log(data, '- SECOND');
            });

            eventEmitter.emit('myEvent', 'Emitted Statement');

            console.log("Statement B");
        </code></pre>
        </li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            <code>
                Statement A
                Emitted Statement - FIRST
                Emitted Statement - SECOND
                Statement B
            </code>
            Спочатку спрацює console.log('Statement A');
            тому що в коді він іде до генерації подій eventEmitter.emit('myEvent', 'Emitted Statement');
            потім спрацює саме цей генератор подій eventEmitter.emit('myEvent', 'Emitted Statement');
            він згенерує спочатку console.log(data, '-FIRST');
            потім згенерує console.log(data, '- SECOND');
            останнім спрацює console.log("Statement B");
            т.к. він йде в потоці коду останнім.
        </pre>
        </br>
        <hr>
        </br>
        <li>Поясніть, що не так із використанням async/await у циклі forEach. Чи працює він належним чином? Ви можете це виправити?
            </br>Розглянемо цей код:
            <pre style="border: 1px solid grey; padding: 10px"><code>
            import fs from 'fs-promise'

            async function printFiles () {
            const files = await getFilePaths() // Assume this works fine

            files.forEach(async (file) => {
                const contents = await fs.readFile(file, 'utf8')
                console.log(contents)
            })
            }

            printFiles()
        </code></pre>
        </li>
        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            async/await у циклі forEach не чекає завершення кожної асинхронної функції, перш ніж перейти до наступної ітерації.
            У цьому коді цикл forEach виконує всі ітерації одночасно, тобто. файли зчитуються одночасно,
            а console.log(contents) спрацьовують у невизначеному порядку.
            Щоб виправити це, ми можемо використовувати цикл for...of, він дозволяє правильно використовувати await і чекати,
            доки кожен файл буде прочитаний, перш ніж переходити до наступного:
            <code>
                import fs from 'fs-promise';

                async function printFiles() {
                    const files = await getFilePaths();

                    for (const file of files) {
                        const contents = await fs.readFile(file, 'utf8');
                        console.log(contents);
                    }
                }
                printFiles();
            </code>
        </pre>
        </br>
        <hr>
        </br>
        <li>Що саме робить module.exports у Node.js і яким би був простий приклад?</li>

        <h2 class="answer">Answer:</h2>
        <pre class="answer-pre">
            Об'єкт module є посиланням на поточний модуль, а його властивість exports визначає всі властивості та методи
            модуля, які можуть бути експортовані та використані в інших модулях за допомогою функції require().
            <code>
                // greet.js
                module.exports = function(name) {
                console.log(`Hi, ${name}!`);
                }
            //==================================================
                // main.js
                const greet = require('./greet');
                greet('Bob'); // output: Hi, Bob!
            </code>
        </pre>
        </br>
        <hr>
    </ol>
    <h1>Wordpress (Не обов'язково)</h1>
    <ol>
        <li>
            <p>Тема WordPress містить, крім іншого, усі файли, наведені нижче. Які з цих файлів використовуватимуться для відображення домашньої сторінки після активації цієї теми?</p>
            <p>(Виберіть усі прийнятні відповіді.)</p>
            <ol>
                <li>page-front.php</li>
                <li>front-page.php</li>
                <li>home.php</li>
                <li>index.php</li>
            </ol>
        </li>
        <li>
            <p>Виберіть всі дії, які виконує наступний рядок коду під час використання у файлі index.php теми WordPress.</p>
            <pre style="border: 1px solid grey; padding: 10px"><code>
        &lt;?php get_header("home"); ?>
            </code></pre>
            <p>(Виберіть усі прийнятні відповіді.)</p>
            <ol>
                <li>Він завантажує файл із ім'ям home.php.</li>
                <li>Він переходить на домашню сторінку вашої теми.</li>
                <li>Він завантажує файл із ім'ям header-home.php.</li>
                <li>Якщо запитаний файл не знайдено, get_header намагатиметься знайти header.php.</li>
            </ol>
        </li>
    </ol>
    test (question).html
    Displaying test (question).html.

</body>
</html>





